- üëã Hi, I‚Äôm @MihailSaslis
- üëÄ I‚Äôm interested in ...Mathematics and Computing
- üå± I‚Äôm currently learning ...Quantum Computing
- üíûÔ∏è I‚Äôm looking to collaborate on ...Quantum Algorithms
- üì´ How to reach me ...anthimos.saslis@gmail.com

<!---
MihailSaslis/MihailSaslis is a ‚ú® special ‚ú® repository because its `README.md` (this file) appears on your GitHub profile.
You can click the Preview link to take a look at your changes.
--->
I'm a research scientist in areas of interest, Mathematics, and Computer Science.
I've been granted a "Best Paper" award in the WebNet '98 World Conference at Orlando, Florida, US.
Worked in IBM in Athens, Greece for nine years - two "IBM Awards."
I'm in the process of completing my work, called "The Trilogy". It consists of three major parts:

(I) Completed detailed analysis of the Riemann zeta function and proof of
the results related to the Riemann Hypothesis. Current work shows how primes are distributed concerning the non-trivial zeros of the Riemann zeta function.

(II) Analysis of the distribution of the decimal digits of the constant pi. I prove that each n-tuple of decimal digits, for any n positive integer, appears in the sequence of digits of the constant pi countably infinite number of times, which implies that any possible tuple of digits appears an equal number of times as we move to infinity. The number of possible outcomes is also countably infinite. Consequently, all possible tuples of digits are uniformly distributed. Further, the constant pi is an infinitely going random process with the invariant to preserve the uniform distribution of all new coming tuples as we move to infinity. The latter could allow the implementation of "luck"/"unpredictability" in computing machines. We describe a novel computational model extending the TM practice and implementing unattended selection among computations by applying a Game Theoretic model. The new model is called the Pi Machine. A sketch of the architecture of the Pi Machine is presented in Remark 1. By this model, we devise an algorithmic language for multithreaded computing that allows us to define computational complexity classes and prove the complexity of multithreaded algorithms.

(III) I shall deal with intractable computing. We will see the Turing Machine computational model suffices to solve intractable problems efficiently. I solve the P vs. NP problem by providing a deterministic polynomial-time solution to the NP-hard problem of the Traveling Salesman Problem (TSP), i.e., P=NP. Consequently, the rigorous and constructive proof of the P = NP will lead to mechanizing Mathematics, that is, we could come up with the solution to David Hilbert's "Decision Problem", where any possible, meaningful, and applicable sentence generated by the formal set of axioms can have an efficient proof generated algorithmically. Further, it will infer that Hilbert's program will eventually prevail on any problem of proving axiomatic sentences despite Godel's Incompleteness Theorem and the Church-Turing Thesis. Moreover, we can automate the generation of exceptional, say sonatas, algorithmically and automatically, even if we don't know how to do it. Undecidability, which will be proven to be hidden in loops, can be proved in a finite time. This opens the door to the successful implementation of D. Hilbert's "Decision Problem", only that we have to decide between three options: True/False proofs, or undecidable cases.

Remark 1. In the TM model we follow an old-age approach to performing computations: input tape, output tape, and scratch workspace for intermediate calculations. Therefore, we model an algorithm/program in some programming language. The Pi Machine model describes all possible algorithms/programs in any programming language executed in a multithreaded computer.
It assumes sets of a finite number of states with their transitions, multiple input/output tapes, one per set of states, private scratch tapes one per set of states, a set of public scratch tapes subject to an injective function from the set of all possible subsets of sets of finite states to the set of all subsets of public scratch tapes. A tape abstracts a private/public computer resource.
Machine configurations appear on the infinite sequence of all possible tuples of the pi digits whose generation has been started at some global discrete time, which is independent and irrelevant to the machine's start and operation, and continues to infinity. All state transitions and head operations are subject to the global (discrete) time. Each atomic tape-head operation (move Left/Right) has its own continuous-time step. Each atomic state transition accessing the tape heads (Read/Write) has its own continuous-time step of tape access. Basic transition operations (add/multiply) have the same continuous-time step. Any machine configuration appears encoded as an n-tuple on the pi-digit infinite sequence. Therefore, any machine snapshot is already stored in the pi sequence.
We denote the characteristic of pi: every n-tuple of decimal pi digits appears uniformly, as the pi sequence is generated towards infinity. We can start generating the decimal digits of pi at any location of the pi generation, and we still get all n-tuples of decimal digits. This characteristic makes time to be irrelevant for the machine operation and its algorithms (TMs). Algorithms are instantiated (in a random or else manner) by the controller of the machine, who selects the beginning of the infinite pi generation. The only thing that remains is to define the time step (discrete) of pi generating digits of its sequence.
The pi generation pre-exists the instantiation of the algorithms, and time in the whole operation is irrelevant.
Since the machine implements all possible algorithms, it could be used to model and measure the complexity of the functionality and communication of all actors/algorithms in a broad society.
All possible predictions of an algorithm are the algorithm's internal routines.
We characterize an event as unexpected if and only if a group of algorithms (TMs), as of their instantiations arranged by the controller, compete for the same resource.
Game-Theoretic algorithms model decision-making on conflicts of unexpected events.
